<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://ifucode.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="isleon">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://ifucode.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SQL学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/09/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T15:56:22.064Z" itemprop="datePublished">2021-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SQL学习笔记"><a href="#SQL学习笔记" class="headerlink" title="SQL学习笔记"></a>SQL学习笔记</h1><p>———————————————————————————————————————————————   V2.0 2021.05</p>
<h2 id="1-SQL基础语法"><a href="#1-SQL基础语法" class="headerlink" title="1 SQL基础语法"></a>1 SQL基础语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select--from--where--group by--having--order by--limit</span><br></pre></td></tr></table></figure>

<p>SQL的学习方法：分步解题，多练，学会逐步生成中间表格（同时也要锻炼无数据库情况下查错能力），积累用法和思路，套用</p>
<h3 id="1-1-describe"><a href="#1-1-describe" class="headerlink" title="1.1 describe"></a>1.1 describe</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe ddm.shop</span><br></pre></td></tr></table></figure>

<p>查看数据字典，表格有哪些【字段】【字段的数据类型】【注释】</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ods</strong>（Operational Data Store）：操作型数据仓库</td>
<td>同步业务生产过程中的所有数据，比edw更加详细，冗余和复杂度也更高</td>
</tr>
<tr>
<td><strong>edw</strong>（Enterprise Data Warehouse）：企业数据库</td>
<td>已处理完成并进行过汇总的，可供业务直接使用的企业数据库</td>
</tr>
<tr>
<td><strong>edw_s</strong>：安全级别更高的企业数据库</td>
<td>存储安全级别较高的敏感或机密数据，例如用户的身份证号、手机号、真实姓名</td>
</tr>
<tr>
<td><strong>ddm</strong>（Distributed Database Middleware）：局部数据库</td>
<td>专门针对某个具体的应用或需求建设的局部数据库，只关心自己需要的数据。不会全盘考虑企业整体的数据架构和应用，每个应用都有自己的DM。所以DM可以基于仓库建设也可以独立建设。</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210220163033.png"></p>
<h3 id="1-2-select"><a href="#1-2-select" class="headerlink" title="1.2 select"></a>1.2 select</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from ddm.shop limit 1000,10 </span><br><span class="line">--用来节约数据库的缓存资源，进行数据的初步查看【默认加limit 10是个好习惯】</span><br></pre></td></tr></table></figure>
<p>select原理是先创建表头，最后生成表，可以理解为执行两次（因为后面group by，order by 1,2,3）</p>
<blockquote>
<p>–查看数据样式，此时的 limit 不需要和 order by 连用，减少消耗的缓存资源</p>
</blockquote>
<h3 id="1-3-from"><a href="#1-3-from" class="headerlink" title="1.3 from"></a>1.3 from</h3><p>从数据库中找到from后指定的表格，复制一张完全一样的表格用于后续的处理和查询</p>
<h3 id="1-4-where"><a href="#1-4-where" class="headerlink" title="1.4 where"></a>1.4 where</h3><p>基于from复制的表格，按照where后的条件对表格中的行进行筛选</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>单个数值精确匹配</td>
</tr>
<tr>
<td>between A and B</td>
<td>匹配包含AB及AB之间的所有值</td>
</tr>
<tr>
<td>in(A,B,C,D)</td>
<td>可以实现多选，not in可以反选</td>
</tr>
<tr>
<td>and/or</td>
<td>可以并列多个条件（and用于不同字段，or用于同一字段</td>
</tr>
<tr>
<td>like</td>
<td>配合通配符进行模糊匹配（’%’代表任意数量字符，”_”只代表单个字符）</td>
</tr>
</tbody></table>
<h3 id="1-5-group-by"><a href="#1-5-group-by" class="headerlink" title="1.5 group by"></a>1.5 group by</h3><p> 对数据进行分组 = 对group by后的字段进行去重合并，并作为后续聚合运算的依据</p>
<blockquote>
<p>group by其实只指定了聚合函数的计算依据，具体的聚合运算还是要由聚合函数进行</p>
<p>==== <strong>group by 重点</strong>：</p>
<p>因为group by先运行，并且运行后，表格中的非聚合字段已经形成了，所以select后的非聚合字段一定要与group by后指定的字段一致</p>
<p>也就是说：group by后没有的非聚合字段select无法显示，但group by后有的非聚合字段select可以选择不显示</p>
</blockquote>
<blockquote>
<p><strong>因为，select会运行两次</strong></p>
<p>第一次最先运行：按照字段原始名称和别名新建表头</p>
<p>第二次最后运行：基于from、join、where、group by、having处理好的数据表格，按照select后的计算规则，计算并在表头后显示字段对应的数值</p>
<p>所以group by可以使用1,2等数字直接引用select后的字段名称，直接用于去重合并</p>
</blockquote>
<h3 id="1-6-having"><a href="#1-6-having" class="headerlink" title="1.6 having"></a>1.6 having</h3><p>由于SQL的单向执行的，而where已经在group by之前执行过了，如果要在group by后再对局和预算的结果进行筛选，需要使用新语句having</p>
<p>并且，having是在分组（去重合并）后运行的，因此having只可以对</p>
<ul>
<li><p><strong>作为分组依据的非聚合字段</strong></p>
</li>
<li><p><strong>任意分组后聚合运算的结果</strong></p>
</li>
</ul>
<p>进行筛选，除了对象，having具体的语法和where完全一致</p>
<h3 id="1-7-order-by"><a href="#1-7-order-by" class="headerlink" title="1.7 order by"></a>1.7 order by</h3><p>按照字段的顺序对表格的行进行排序，默认升序，字段后加DESC为降序</p>
<blockquote>
<p>order by在select前运行，因此可以依据select后没有，但表格中有的字段进行排序</p>
</blockquote>
<h3 id="1-8-limit"><a href="#1-8-limit" class="headerlink" title="1.8 limit"></a>1.8 limit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit 1    --检索第一行</span><br><span class="line">limit 1,1  --检索第二行</span><br><span class="line">limit 3,4  --相当于 limit 4 offset 3 --（注意位置反过来） 检索4，5，6，7行 </span><br><span class="line">--limit不是所有DBMS都适用</span><br></pre></td></tr></table></figure>

<ul>
<li>查看数据也可用top</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--前5行</span><br><span class="line">select top 5 * from table</span><br><span class="line">--后5行</span><br><span class="line">select top 5 * from table order by id desc  --desc 表示降序排列 asc 表示升序</span><br></pre></td></tr></table></figure>

<ul>
<li><p>limit 和 order by 连用</p>
<p>按照order by排序后的表格，限制最终显示表格的行数，常用来取固定名次的数据</p>
</li>
</ul>
<p>应用：超大分页查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where age &gt; 20 limit 1000000,10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，当offset特别大的时候，效率就非常低下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--正例</span><br><span class="line">select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</span><br><span class="line">select a.* from 表1 a,(select id from 表1 where 条件 limit 1000000,10) b where a.id = b.id</span><br></pre></td></tr></table></figure>

<h3 id="1-9-聚合函数"><a href="#1-9-聚合函数" class="headerlink" title="1.9 聚合函数"></a>1.9 聚合函数</h3><p>聚合函数也可以不和group by一起用，这样就可以求整个表格的数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(GMV) from ddm.shop</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sum()</td>
<td>返回总和</td>
</tr>
<tr>
<td>count()</td>
<td>返回行数</td>
</tr>
<tr>
<td>avg()</td>
<td>返回平均值</td>
</tr>
<tr>
<td>max()</td>
<td>返回最大值</td>
</tr>
<tr>
<td>min()</td>
<td>返回最小值</td>
</tr>
</tbody></table>
<p>count(*)可以快速查看表格有多少行，又不占用太多资源</p>
<h3 id="1-10-distinct"><a href="#1-10-distinct" class="headerlink" title="1.10 distinct"></a>1.10 distinct</h3><p>distinct只能在select后，第一个筛选字段前，可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct 门店名称)</span><br></pre></td></tr></table></figure>

<p>同时对两个字段去重，同Excel会删除两个字段都重复的，类似于筛选’A+B’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct 门店名称,品牌名称 from ddm.shop</span><br></pre></td></tr></table></figure>

<p>可以用group by实现多个字段去重合并，作用同distinct</p>
<h3 id="1-11-执行顺序"><a href="#1-11-执行顺序" class="headerlink" title="1.11 执行顺序"></a>1.11 执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from--join(on--and)--where--group by--having--窗口函数--order by--limit--select </span><br><span class="line">--部分分享会说 select 在 order by 之前</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: from</span><br><span class="line">op1=&gt;operation: on</span><br><span class="line">op2=&gt;operation: join</span><br><span class="line">op3=&gt;operation: where</span><br><span class="line">op4=&gt;operation: group by</span><br><span class="line">op5=&gt;operation: having</span><br><span class="line">op6=&gt;operation: 窗口函数</span><br><span class="line">op7=&gt;operation: order by</span><br><span class="line">op8=&gt;operation: limit</span><br><span class="line">e=&gt;end: select</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;op5(right)-&gt;op6(right)-&gt;op7(right)-&gt;op8(right)-&gt;e</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>order by之前称为准备表格</p>
<p>order by之后为查询字段</p>
<p>在阅读SQL代码和书写时，可以先从from和join语句看起，明确用了哪些表，然后看select查询和创建了哪些字段，接下来细致研究代码细节，最后看where的筛选逻辑</p>
<h3 id="1-12-别名"><a href="#1-12-别名" class="headerlink" title="1.12 别名"></a>1.12 别名</h3><ul>
<li><p>咨询别名规则</p>
</li>
<li><p>表和变量名中不要出现空格，可使用下划线  ‘_’</p>
</li>
<li><p>函数名不能用于别名，如窗口函数别名不能用 ‘rank’</p>
</li>
<li><p>在各个库中，表和字段别名尽量统一，方便代码移植，减少使用a,b来别名，别名要有含义</p>
</li>
</ul>
<h2 id="2-SQL进阶"><a href="#2-SQL进阶" class="headerlink" title="2 SQL进阶"></a>2 SQL进阶</h2><h3 id="2-1-表连接"><a href="#2-1-表连接" class="headerlink" title="2.1 表连接"></a>2.1 表连接</h3><h4 id="2-1-1-join"><a href="#2-1-1-join" class="headerlink" title="2.1.1 join"></a>2.1.1 join</h4><ul>
<li><p>left join :左连接，返回左表中所有的记录以及右表中连接字段相等的记录。</p>
</li>
<li><p>right join :右连接，返回右表中所有的记录以及左表中连接字段相等的记录。</p>
</li>
<li><p>(join) inner join: 内连接，又叫等值连接，只返回两个表中连接字段相等的行。</p>
</li>
<li><p>full join:外连接，返回两个表中的行：left join + right join。</p>
<ul>
<li>mysql不支持完全外部连接，需要union两个左右连接</li>
</ul>
</li>
<li><p>cross join:结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</p>
</li>
</ul>
<p>关键字: on</p>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。</p>
<blockquote>
<p>表面上，join是各种逻辑的表连接，实际上，join是一种运算逻辑（算法）</p>
<ul>
<li>遍历匹配，向下增添（不同于vlookup,vlookup只匹配第一个）</li>
<li>左右连接就是保留数据</li>
</ul>
</blockquote>
<p>假设有两张表：</p>
<p>表1： tab1</p>
<table>
<thead>
<tr>
<th>name</th>
<th>id</th>
</tr>
</thead>
<tbody><tr>
<td>AAA</td>
<td>1</td>
</tr>
<tr>
<td>BBB</td>
<td>2</td>
</tr>
<tr>
<td>CCC</td>
<td>3</td>
</tr>
<tr>
<td>CCC</td>
<td>4</td>
</tr>
</tbody></table>
<p>表2： tab2</p>
<table>
<thead>
<tr>
<th>name</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>BBB</td>
<td>10</td>
</tr>
<tr>
<td>CCC</td>
<td>20</td>
</tr>
<tr>
<td>BBB</td>
<td>30</td>
</tr>
<tr>
<td>DDD</td>
<td>40</td>
</tr>
</tbody></table>
<p>中间表 on条件：tab1.name = tab2.name</p>
<table>
<thead>
<tr>
<th>tab1.name</th>
<th>tab1.id</th>
<th>tab2.name</th>
<th>tab2.size</th>
</tr>
</thead>
<tbody><tr>
<td>AAA</td>
<td>1</td>
<td><font color='lightgray'><em>null</em></font></td>
<td><font color='lightgray'><em>null</em></font></td>
</tr>
<tr>
<td>BBB</td>
<td>2</td>
<td>BBB</td>
<td>10</td>
</tr>
<tr>
<td>BBB</td>
<td>2</td>
<td>BBB</td>
<td>30</td>
</tr>
<tr>
<td>CCC</td>
<td>3</td>
<td>CCC</td>
<td>20</td>
</tr>
<tr>
<td>CCC</td>
<td>4</td>
<td>CCC</td>
<td>20</td>
</tr>
<tr>
<td><font color='lightgray'><em>null</em></font></td>
<td><font color='lightgray'><em>null</em></font></td>
<td>DDD</td>
<td>40</td>
</tr>
</tbody></table>
<p>举例左连接left join结果（只保留左侧连接建不为空的行），注意两个连接键都会保留，故不能同名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * form tab1 left join tab2 on tab1.name = tab2.name</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>tab1.name</th>
<th>tab1.id</th>
<th>tab2.name</th>
<th>tab2.size</th>
</tr>
</thead>
<tbody><tr>
<td>AAA</td>
<td>1</td>
<td><font color='lightgray'><em>null</em></font></td>
<td><font color='lightgray'><em>null</em></font></td>
</tr>
<tr>
<td>BBB</td>
<td>2</td>
<td>BBB</td>
<td>10</td>
</tr>
<tr>
<td>BBB</td>
<td>2</td>
<td>BBB</td>
<td>30</td>
</tr>
<tr>
<td>CCC</td>
<td>3</td>
<td>CCC</td>
<td>20</td>
</tr>
<tr>
<td>CCC</td>
<td>4</td>
<td>CCC</td>
<td>20</td>
</tr>
</tbody></table>
<blockquote>
<p>on后面的筛选条件和where的筛选条件有什么不同？</p>
<ul>
<li><p>on比where运行得早，数据库会根据on的条件对数据进行筛选再进行连接</p>
</li>
<li><p>而where则是连接完成后，再进行筛选</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * form tab1 left join tab2 on tab1.name = tab2.name and tab2.size = 30</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>tab1.name</th>
<th>tab1.id</th>
<th>tab2.name</th>
<th>tab2.size</th>
</tr>
</thead>
<tbody><tr>
<td>AAA</td>
<td>1</td>
<td><font color='lightgray'><em>null</em></font></td>
<td><font color='lightgray'><em>null</em></font></td>
</tr>
<tr>
<td>BBB</td>
<td>2</td>
<td>BBB</td>
<td>30</td>
</tr>
<tr>
<td>CCC</td>
<td>3</td>
<td><font color='lightgray'><em>null</em></font></td>
<td><font color='lightgray'><em>null</em></font></td>
</tr>
<tr>
<td>CCC</td>
<td>4</td>
<td><font color='lightgray'><em>null</em></font></td>
<td><font color='lightgray'><em>null</em></font></td>
</tr>
</tbody></table>
<h4 id="2-1-2-union"><a href="#2-1-2-union" class="headerlink" title="2.1.2 union"></a>2.1.2 union</h4><p>union 和 union all 的区别</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>union</th>
<th>union all</th>
</tr>
</thead>
<tbody><tr>
<td>对重复结果的处理不同</td>
<td>取唯一值，记录没有重复（union在进行表链接后会筛选掉重复的记录）</td>
<td>直接连接，取到得是所有值，记录可能有重复</td>
</tr>
<tr>
<td>对排序的处理不同</td>
<td>按照字段的顺序进行排序</td>
<td>简单的将两个结果合并后就返回</td>
</tr>
</tbody></table>
<p>从效率上说，union all 要比union快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用union all。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">&gt;=</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">&lt;=</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li><p>1、union 和 union all都可以将多个结果集合并，而不仅仅是两个，所以可将多个结果集串起来。 </p>
</li>
<li><p>2、使用union和union all必须保证各个select 集合的结果有相同个数的列，并且每个列的类型是一样的。但列名则不一定需要相同，oracle会将第一个结果的列名作为结果集的列名。</p>
</li>
</ul>
<h4 id="2-1-3-whit-as"><a href="#2-1-3-whit-as" class="headerlink" title="2.1.3 whit as"></a>2.1.3 whit as</h4><ol>
<li><p>SQL可读性增强。比如对于特定with子查询取个有意义的名字等。</p>
</li>
<li><p>with子查询只执行一次，将结果存储在用户临时表空间中，可以引用多次，增强性能。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span></span><br><span class="line">sql1 <span class="keyword">as</span> (<span class="keyword">select</span> to_char(a) s_name <span class="keyword">from</span> test_tempa),</span><br><span class="line">sql2 <span class="keyword">as</span> (<span class="keyword">select</span> to_char(b) s_name <span class="keyword">from</span> test_tempb <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> s_name <span class="keyword">from</span> sql1 <span class="keyword">where</span> rownum<span class="operator">=</span><span class="number">1</span>))</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sql1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sql2</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> ‘<span class="keyword">no</span> records’ <span class="keyword">from</span> dual</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> s_name <span class="keyword">from</span> sql1 <span class="keyword">where</span> rownum<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> s_name <span class="keyword">from</span> sql2 <span class="keyword">where</span> rownum<span class="operator">=</span><span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-窗口函数"><a href="#2-2-窗口函数" class="headerlink" title="2.2 窗口函数"></a>2.2 窗口函数</h3><blockquote>
<p>表面上，窗口函数是基于某个排序规则进行排序并计算</p>
<p>实际上，窗口函数是对准备好的表格，在任意分组内部进行排序和计算（为了区分，我们称之为分区）（也就是指定任意详细级别进行各种自定义的运算）</p>
<ol>
<li> from–where之后，再创建一个之前准备好的表格（还未排序和限制）</li>
<li> 根据partition by 后的字段（没有则默认针对整个表）形成的分区（不去重合并）</li>
<li>在分区内根据order by后的条件对所有行进行排序<pre><code>- 注意：mysql支持在over中使用聚合字段

- ```mysql
  row_number() over(partition by 门店名称 order by sum(gmv)) r
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4.  计算over()前函数的结果</span><br><span class="line"></span><br><span class="line">#### 2.2.1 row_number/dense_rank/rank</span><br><span class="line"></span><br><span class="line">根据排序分配序号</span><br><span class="line"></span><br><span class="line">| 函数名       | 备注                                         | 举例      |</span><br><span class="line">| ------------ | -------------------------------------------- | --------- |</span><br><span class="line">| row_number() | 根据分区内的排序，分配唯一且连续排名序号     | 1,2,3,4,5 |</span><br><span class="line">| dense_rank() | 根据分区内的排序，分配不唯一且连续排名序号   | 1,1,2,2,3 |</span><br><span class="line">| rank()       | 根据分区内的排序，分配不唯一且不连续排名序号 | 1,1,3,3,5 |</span><br><span class="line"></span><br><span class="line">如果是时间排序，注意确定好详细级别</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">,row_number() over(partition by 门店名称,平台 order by 日期) r</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,dense_rank() over(partition by 门店名称,平台 order by 日期) dense_r</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,rank() over(partition by 门店名称,平台 order by 日期) rank_r</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-first-value-nth-value"><a href="#2-2-2-first-value-nth-value" class="headerlink" title="2.2.2 first_value/nth_value"></a>2.2.2 first_value/nth_value</h4><p>根据排序取具体字段数值</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>first_value(字段)</td>
<td>根据分区内的排序，返回排在第一行的对应的字段数值（降序就可以去最后一行对应的数值）</td>
</tr>
<tr>
<td>nth_value(字段,n)</td>
<td>返回分区内的排序第n行的字段数值。如果第n行还未运行到，则返回<font color='gray'><null></font>。n必须是正整数，例如1,2和3。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,first_value(GMV) over(partition by 门店名称,平台 order by 日期) first_gmv</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,first_value(GMV) over(partition by 门店名称,平台 order by 日期 desc) last_gmv</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,nth_value(GMV,3) over(partition by 门店名称,平台 order by 日期) nth_gmv_3</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225114058.png"></p>
<h4 id="2-2-3-lag-lead"><a href="#2-2-3-lag-lead" class="headerlink" title="2.2.3 lag/lead"></a>2.2.3 lag/lead</h4><p>根据排序取上下几行的数值</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>lag(字段,n,默认值)</td>
<td>返回分区内，本行前n行的字段数值，如果为空则填充默认值</td>
</tr>
<tr>
<td>lead(字段,n,默认值)</td>
<td>返回分区内，本行后n行的字段数值，如果为空则填充默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,lag(gmv,2) over(partition by 门店名称,平台 order by 日期) lag_2</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225114633.png" style="zoom: 80%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,lag(gmv,2,666) over(partition by 门店名称,平台 order by 日期) lag_2b</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225114711.png" style="zoom: 80%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,lead(gmv,2) over(partition by 门店名称,平台 order by 日期) lead_2</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225114833.png" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,lead(gmv,2,666) over(partition by 门店名称,平台 order by 日期) lead_2b</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-percent-rank-cume-dist"><a href="#2-2-4-percent-rank-cume-dist" class="headerlink" title="2.2.4 percent_rank/cume_dist"></a>2.2.4 percent_rank/cume_dist</h4><p>根据排序统计分布位置</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>备注</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>percent_rank()</td>
<td>根据分区内的排序，从0开始统计当前行所在排序中的处于百分之多少的位置（不管指定值与分组序列中某值是否重复，均将此值视为序列一部分）</td>
<td>0&lt;= percent_rank() &lt;=1</td>
</tr>
<tr>
<td>cume_dist()</td>
<td>根据分区内的排序，从0之后开始统计当前行所在排序中的百分比分布位置（如果指定值与分组序列中某值重复，则将二值视为一个值处理）</td>
<td>0&lt; cume_dist() &lt;=1</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,percent_rank() over(partition by 门店名称,平台 order by 日期) perpos</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,cume_dist() over(partition by 门店名称,平台 order by 日期) pos</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210503184159.png"></p>
<p>cume_dist的计算方法：<strong>小于等于当前行值的行数/总行数</strong>。</p>
<ul>
<li><p>比如，第3行值为10，有3行的值小于等于10,总行数10行，因此CUME_DIST为3/10=0.3 。</p>
</li>
<li><p>再比如，第4行值为40，行值小于等于40的共5行，总行数10行，因此CUME_DIST为5/10=0.5 </p>
</li>
</ul>
<p>PERCENT_RANK的计算方法：<strong>当前RANK值-1/总行数-1</strong> 。</p>
<ul>
<li><p>比如，第4行的RANK值为4，总行数10行，因此PERCENT_RANK为4-1/10-1= <strong>0.333333333333333</strong>。</p>
</li>
<li><p>再比如，第7行的RANK值为6，总行数10行，因此PERCENT_RANK为6-1/10-1=<strong>0.555555555555556</strong>。</p>
</li>
</ul>
<h4 id="2-2-5-ntile"><a href="#2-2-5-ntile" class="headerlink" title="2.2.5 ntile"></a>2.2.5 ntile</h4><p>在排序内分组</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ntile(n)</td>
<td>将排序内的行分为n组，根据分区内的排序，返回每一行是第几组</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,ntile(4) over(partition by 门店名称,平台 order by 日期) ntile_r</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210503184244.png" style="zoom:80%;" />

<blockquote>
<p>无论最终查询出的表格排序如何，窗口函数计算的列都只根窗口函数<strong>指定排序</strong>下的计算结果一致</p>
</blockquote>
<h4 id="2-2-6-取四分位各函数效率及准确率比较"><a href="#2-2-6-取四分位各函数效率及准确率比较" class="headerlink" title="2.2.6 取四分位各函数效率及准确率比较"></a>2.2.6 取四分位各函数效率及准确率比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">,row_number() over( order by amount desc) 		r</span><br><span class="line">,rank() over (order by amount desc)             rank_r</span><br><span class="line">,ntile(4) over( order by amount desc) 			ntile_r</span><br><span class="line">,cume_dist() over (order by amount desc) 		cume_r</span><br><span class="line">,percent_rank() over (order by amount desc) 	percent_r</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225165944.png"></p>
<p>总数54，计算四分位应该在13，以上方法中最快的是cume_dist（percent_rank和row_number都需要再绕一步）</p>
<h4 id="2-2-7-各种聚合运算都支持"><a href="#2-2-7-各种聚合运算都支持" class="headerlink" title="2.2.7 各种聚合运算都支持"></a>2.2.7 各种聚合运算都支持</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum()over()</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>over()中分为partition by子句、order by子句和window子句</li>
<li>只使用partition by子句,未指定order by,聚合为分组内的聚合</li>
<li>使用partition by和order by子句,未使用window子句的情况下,默认从起点到当前行</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avg()over()</span><br><span class="line">count()over()</span><br><span class="line">max()over()</span><br><span class="line">min()over()</span><br></pre></td></tr></table></figure>

<h4 id="2-2-8-窗口子句（window子句）"><a href="#2-2-8-窗口子句（window子句）" class="headerlink" title="2.2.8 窗口子句（window子句）"></a>2.2.8 窗口子句（window子句）</h4><ul>
<li><p>preceding：往前</p>
</li>
<li><p>following：往后</p>
</li>
<li><p>current row：当前行</p>
</li>
<li><p>unbounded：起点</p>
<ul>
<li><p>unbounded preceding 表示从前面的起点</p>
</li>
<li><p>unbounded following  表示到后面的终点</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(GMV)over(partition by 门店名称,平台) 分区和</span><br><span class="line">sum(GMV)over(partition by 门店名称,平台 order by GMV desc) 分区第1行到当前行的累计和</span><br><span class="line">sum(GMV)over(partition by 门店名称,平台 order by GMV desc rows 2 preceding) 分区前2行和当前行的累计和</span><br><span class="line">sum(GMV)over(partition by 门店名称,平台 order by GMV desc rows between unbounded preceding and 1 preceding) 分区第1行到前1行的累计和</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210504200656.png"></p>
<h2 id="3-特殊函数用法"><a href="#3-特殊函数用法" class="headerlink" title="3 特殊函数用法"></a>3 特殊函数用法</h2><h3 id="3-1-数值处理函数"><a href="#3-1-数值处理函数" class="headerlink" title="3.1 数值处理函数"></a>3.1 数值处理函数</h3><h4 id="3-1-1-round"><a href="#3-1-1-round" class="headerlink" title="3.1.1 round"></a>3.1.1 round</h4><p>round(数值型字段,n)：对数值型字段取小数点后n位小数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--n为正整数时，取小数点后n位小数</span><br><span class="line">round(3141.592,2) = 3141.59</span><br><span class="line">--n为负整数时，取小数点前n位小数</span><br><span class="line">round(3141.592,-2) = 3100</span><br><span class="line">--注意：round()是四舍五入，不是直接截取，截取用left</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select ceil(23.33) from dual;		--24	返回大于或等于x的最大整数</span><br><span class="line">select floor(23.33) from dual;		--23	返回等于或小于x的最大整数</span><br><span class="line">select round(23.33) from dual;		--23	返回舍入到小数点右边y位的x值:rcund(x,[y])</span><br><span class="line">select trunc(23.33) from dual;		--23	返回截尾到y位小数的x值:trunc(x,[y])，只截取不舍入</span><br><span class="line">select sign(-23.33) from dual;		-1		返回x的符号</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-abs"><a href="#3-1-2-abs" class="headerlink" title="3.1.2 abs"></a>3.1.2 abs</h4><p>abs(数值型字段)：取数值型字段的绝对值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abs(-666) = 666</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-coalesce"><a href="#3-1-3-coalesce" class="headerlink" title="3.1.3 coalesce"></a>3.1.3 coalesce</h4><p>coalesce(字段,数值)：将字段中的null填充为默认数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COALESCE ( expression1, expression2 );</span><br><span class="line">    CASE WHEN expression1 IS NOT NULL THEN expression1 ELSE expression2 END;</span><br><span class="line">COALESCE ( expression1, expression2, ... expression-n );</span><br><span class="line">--表示如果第一个不为空取第一个，否则判断下一个，以此类推，如果全部为空，则返回null值。</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-isnull"><a href="#3-1-4-isnull" class="headerlink" title="3.1.4 isnull"></a>3.1.4 isnull</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isnull(exper)  --判断exper是否为空，是则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5-ifnull"><a href="#3-1-5-ifnull" class="headerlink" title="3.1.5 ifnull"></a>3.1.5 ifnull</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifnull(exper1,exper2)  --判断exper1是否为空，是则用exper2代替</span><br></pre></td></tr></table></figure>

<h4 id="3-1-6-nullif"><a href="#3-1-6-nullif" class="headerlink" title="3.1.6 nullif"></a>3.1.6 nullif</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nullif(exper1,exper2)  --如果expr1= expr2 成立，那么返回值为NULL，否则返回值为expr1</span><br></pre></td></tr></table></figure>

<h3 id="3-2-数据类型转化"><a href="#3-2-数据类型转化" class="headerlink" title="3.2 数据类型转化"></a>3.2 数据类型转化</h3><h4 id="3-2-1-cast"><a href="#3-2-1-cast" class="headerlink" title="3.2.1 cast"></a>3.2.1 cast</h4><p>cast(字段 as 要转换成的数据类型)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast(日期 as date)  --常用转化类型: date / text / int</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.runoob.com/mysql/mysql-data-types.html">Mysql所有数据类型:</a> </p>
<h3 id="3-3-字符处理函数"><a href="#3-3-字符处理函数" class="headerlink" title="3.3 字符处理函数"></a>3.3 字符处理函数</h3><h4 id="3-3-1-substring"><a href="#3-3-1-substring" class="headerlink" title="3.3.1 substring"></a>3.3.1 substring</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substring(字段,从第n位开始取,往后取m位)=mid()  --可以直接处理时间类型的数据</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-left"><a href="#3-3-2-left" class="headerlink" title="3.3.2 left"></a>3.3.2 left</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left(字段,从左边一位开始往后取几位)/right()</span><br><span class="line">left(&#x27;MySQL LEFT&#x27;, 5) = MySQL </span><br><span class="line">right(&#x27;MySQL LEFT&#x27;, 5) =  LEFT</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-concat"><a href="#3-3-3-concat" class="headerlink" title="3.3.3 concat"></a>3.3.3 concat</h4><ul>
<li>连接括号内任意的字符串</li>
<li>也可以直接处理时间类型的数据，因为时间类型的数据本质就是字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,concat(round((a.当月GMV / b.季度GMV)*100,2),&#x27;%&#x27;) 占比</span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-replace"><a href="#3-3-4-replace" class="headerlink" title="3.3.4 replace"></a>3.3.4 replace</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(abbc,&#x27;bb&#x27;,&#x27;cc&#x27;) = accc</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-ucase"><a href="#3-3-5-ucase" class="headerlink" title="3.3.5 ucase"></a>3.3.5 ucase</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ucase(需要大写的字段)=upper(str)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-6-lcase"><a href="#3-3-6-lcase" class="headerlink" title="3.3.6 lcase"></a>3.3.6 lcase</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcase(需要小写的字段)=lower(str)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-7-len"><a href="#3-3-7-len" class="headerlink" title="3.3.7 len()"></a>3.3.7 len()</h4><p>len()返回某个文本字段的长度</p>
<h4 id="3-3-8-position"><a href="#3-3-8-position" class="headerlink" title="3.3.8 position()"></a>3.3.8 position()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position(&#x27;,&#x27; in city_state) -- 返回‘,’在city_state中的位置</span><br></pre></td></tr></table></figure>

<h3 id="3-4-时间函数"><a href="#3-4-时间函数" class="headerlink" title="3.4 时间函数"></a>3.4 时间函数</h3><h4 id="3-4-1-date-format"><a href="#3-4-1-date-format" class="headerlink" title="3.4.1 date_format"></a>3.4.1 date_format</h4><p>date_format() - 格式化某个字段的显示方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(NOW(),&#x27;%b %d %Y %h:%i %p&#x27;)</span><br><span class="line">--运行结果：</span><br><span class="line">Dec 29 2008 11:45 PM</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_date_format.asp">MySQL DATE_FORMAT() 函数</a></p>
<p>MySQL时间数据的默认格式</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td>YEAR</td>
<td>YYYY 或 YY</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATE()		--提取日期或日期/时间表达式的日期部分</span><br><span class="line">month() 	--取月份返回一个数字</span><br><span class="line">year()  	--取年份返回一个数字</span><br><span class="line">NOW()		--返回当前的日期和时间</span><br><span class="line">CURDATE()	--返回当前的日期</span><br><span class="line">CURTIME()	--返回当前的时间</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-date-add"><a href="#3-4-2-date-add" class="headerlink" title="3.4.2 date_add"></a>3.4.2 date_add</h4><p>date_add() 在日期中添加或减去指定的时间间隔（时间偏移）</p>
<p>date_add(date,interval n 时间单位)在日期往后偏移n个时间单位（可以为负数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case when cast(midw.cre_dt as date) &lt;= date_add(cast(uif.cmdat_mmv_suc_ft as date),interval 2 month)</span><br></pre></td></tr></table></figure>

<p>date_sub(date,interval n 时间单位)在日期往前偏移n个时间单位（可以为负数）</p>
<table>
<thead>
<tr>
<th>时间单位</th>
<th>时间单位</th>
</tr>
</thead>
<tbody><tr>
<td>MICROSECOND</td>
<td></td>
</tr>
<tr>
<td>SECOND</td>
<td>SECOND_MICROSECOND</td>
</tr>
<tr>
<td>MINUTE</td>
<td>MINUTE_MICROSECOND，MINUTE_SECOND</td>
</tr>
<tr>
<td>HOUR</td>
<td>HOUR_MICROSECOND，HOUR_SECOND，HOUR_MINUTE，</td>
</tr>
<tr>
<td>DAY</td>
<td>DAY_MICROSECOND，DAY_SECOND，DAY_MINUTE，DAY_HOUR</td>
</tr>
<tr>
<td>WEEK</td>
<td></td>
</tr>
<tr>
<td>MONTH</td>
<td></td>
</tr>
<tr>
<td>QUARTER</td>
<td></td>
</tr>
<tr>
<td>YEAR</td>
<td>YEAR_MONTH</td>
</tr>
</tbody></table>
<h4 id="3-4-3-datediff"><a href="#3-4-3-datediff" class="headerlink" title="3.4.3 datediff"></a>3.4.3 datediff</h4><p>datediff(date1,date2)函数返回两个日期之间的天数。（注意date1 &gt; date2，结果为正）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEDIFF(&#x27;2008-12-30&#x27;,&#x27;2008-12-29&#x27;) AS DiffDate</span><br><span class="line">-- 返回 1</span><br><span class="line">-- datediff取时间间隔（秒、日、月、天）</span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-timestampdiff"><a href="#3-4-4-timestampdiff" class="headerlink" title="3.4.4 timestampdiff"></a>3.4.4 timestampdiff</h4><p>timestampdiff(时间单位,开始时间,结束时间) 返回结束时间和开始时间之间有多少个时间单位。（注意date1 &lt; date2，结果为正）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timestampdiff(month,date1,date2)  --日期2和日期1之间相差几个月</span><br><span class="line">timestampdiff(second,date1,date2) --日期2和日期1之间相差多少秒</span><br></pre></td></tr></table></figure>

<h3 id="3-5-逻辑函数"><a href="#3-5-逻辑函数" class="headerlink" title="3.5 逻辑函数"></a>3.5 逻辑函数</h3><h4 id="3-5-1-if"><a href="#3-5-1-if" class="headerlink" title="3.5.1 if"></a>3.5.1 if</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(condition, value_if_true, value_if_false)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">,if(branch = &#x27;上海分行&#x27;,1,0)</span><br><span class="line">,if(branch = &#x27;上海分行&#x27;)    --sql默认判断1，0</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-case-when"><a href="#3-5-2-case-when" class="headerlink" title="3.5.2 case when"></a>3.5.2 case when</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case when 条件1 then 数值1 </span><br><span class="line">	 when 条件2 then 数值2 </span><br><span class="line">	 else 数值3 end</span><br></pre></td></tr></table></figure>

<p>逻辑函数的经典用法</p>
<ul>
<li><p>数值替换</p>
</li>
<li><p>条件计算</p>
</li>
<li><p>任意多选</p>
</li>
<li><p>行列转置</p>
</li>
</ul>
<h2 id="4-报错汇总"><a href="#4-报错汇总" class="headerlink" title="4 报错汇总"></a>4 报错汇总</h2><h3 id="4-1-group-by-报错"><a href="#4-1-group-by-报错" class="headerlink" title="4.1 group by 报错"></a>4.1 group by 报错</h3><p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225010652.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[42000][1055] Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;edw.dsx_listing_info.user_id&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure>

<p>select 选取分组中的列+聚合函数 from 表名称 group by 分组的列<br>从语法格式来看，是先有分组，再确定检索的列，检索的列只能在参加分组的列中选。</p>
<p>再看一下only_full_group_by的意思是：对于 group by聚合操作，如果在select 中的列，没有在 group by中出现，那么这个SQL是不合法的，因为列不在 group by从句中，也就是说查出来的列必须在group by后面出现否则就会报错，或者这个字段出现在聚合函数里面。</p>
<p><strong>解决：</strong>group by 后面补上缺失的非聚合字段</p>
<h3 id="4-2-from子查询-别名报错"><a href="#4-2-from子查询-别名报错" class="headerlink" title="4.2 from子查询 别名报错"></a>4.2 from子查询 别名报错</h3><p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225014550.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[42000][1248] Every derived table must have its own alias</span><br></pre></td></tr></table></figure>

<p>from子查询必须要有别名</p>
<h3 id="4-3-where聚合函数的无效用法"><a href="#4-3-where聚合函数的无效用法" class="headerlink" title="4.3 where聚合函数的无效用法"></a>4.3 where聚合函数的无效用法</h3><p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225015131.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HY000][1111] Invalid use of group function</span><br></pre></td></tr></table></figure>

<p>“聚合函数的无效用法”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--错句示例：</span><br><span class="line">SELECT sname AS &#x27;优秀学生姓名&#x27;</span><br><span class="line">,AVG(score) as &#x27;平均成绩&#x27; </span><br><span class="line">FROM `grade_info` </span><br><span class="line">WHERE AVG(score)&gt;90 </span><br><span class="line">GROUP BY sno;</span><br><span class="line"></span><br><span class="line">--正确写法：</span><br><span class="line">SELECT sname AS &#x27;优秀学生姓名&#x27;</span><br><span class="line">,AVG(score) as &#x27;平均成绩&#x27; </span><br><span class="line">FROM `grade_info` </span><br><span class="line">GROUP BY sno </span><br><span class="line">HAVING AVG(score) &gt; 90 ;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-join表后字段名重复"><a href="#4-4-join表后字段名重复" class="headerlink" title="4.4 join表后字段名重复"></a>4.4 join表后字段名重复</h3><p><img src="https://gitee.com/isleon/BlogImage/raw/master/img/20210225021625.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[42S21][1060] Duplicate column name &#x27;日期&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>解决：</strong>通常同名是连接键，把其中一张表的同名字段别名或者带上表名称</p>
<h2 id="5-代码规范"><a href="#5-代码规范" class="headerlink" title="5 代码规范"></a>5 代码规范</h2><h3 id="第一版："><a href="#第一版：" class="headerlink" title="第一版："></a>第一版：</h3><ul>
<li>多写注释</li>
<li>逗号写在字段前面</li>
<li>注意换行<ul>
<li>每行尽量以核心语句开头</li>
<li>核心语句后的内容能写在一行尽量写在一行</li>
<li>where条件过长时，每个都要换行</li>
</ul>
</li>
<li>注意缩进<ul>
<li>case when 同一级别的条件</li>
<li>子查询，子查询可以换行缩进，也可以直接在代码后缩进</li>
<li>别名尽量统一缩进</li>
</ul>
</li>
<li>代码结束处加 ‘;’ </li>
</ul>
<h3 id="第二版："><a href="#第二版：" class="headerlink" title="第二版："></a>第二版：</h3><p>查询核心语句顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select 字段</span><br><span class="line">from 表</span><br><span class="line">join/left join/right join 表 on 连接键</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 聚合分组</span><br><span class="line">having 聚合后的筛选条件</span><br><span class="line">order by 排序</span><br><span class="line">limit 限制</span><br><span class="line"></span><br><span class="line">union 合并查询</span><br></pre></td></tr></table></figure>

<p>一、短代码-仅含 select 和 from，且 select 后字段不超过3个</p>
<ol>
<li>短代码不换行，直接写成一行</li>
</ol>
<p>二、长代码<br>01. 核心语句换行，join 连接表换行，on 连接键换行，多连接键也换行<br>02. where/having 多条件 and/or 换行，单条件语句不换行，例如：between and、sif.branch in (‘上海分行’,’北京分行’)<br>03. group by 后字段不换行，order by 后字段不换行<br>04. 括号内不加空格，函数的括号前不加空格，括号内不加空格,例如：(‘上海分行’,’北京分行’)、sum(amount)<br>05. 运算符前后加空格：= 、&gt;=、&lt;=、&gt;、&lt;、!=、-、+<br>06. 含乘除的运算符前后不加空格：<em>、/、%</em><br>07. select 后只有一个字段不换行，select 后的*算作一个字段来看<br>08. distinct 不换行<br>09. 子查询缩进-select后子查询，括号换行，子查询缩进在括号后，括号上下对齐<br>10. 子查询缩进-from后子查询，括号换行，括号与from同一缩进，括号中的查询缩进在括号后<br>11. 子查询缩进-from后两个子查询连接，join前后空行，保证两个被连接的子查询与 from 和 join 在同一缩进，括号上下对齐<br>12. 子查询缩进-where后子查询，括号不换行，括号在in/运算符 后，子查询缩进在括号后，括号上下对齐<br>13. union前后为完整查询语句，且需要前后空行，完整查询语句不需要括号<br>14. 窗口函数不换行<br>15. 函数嵌套，函数除了 case when 其余函数和函数的多重嵌套都写一行<br>16. case when 函数，仅有一对when和then时，全部写一行<br>17. case when 函数，when 后仅一个条件时，when 和 then 在同一行，若 when 后有多个条件时 then 换行，且前后的 then 都换行，保持代码块内格式统一<br>18. case when 函数，else 和 end 在同一行，case when 函数在本身有换行时，外面嵌套的函数，后半个括号要换行与前半个括号上下对齐<br>19. case when 函数嵌套，then 换行与 when 对齐<br>20. with as 中间表，表名换行，括号换行，代码缩进在括号后，多个中间表时加空行区分</p>
<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h2><h3 id="6-1-Datagrip-数据导出"><a href="#6-1-Datagrip-数据导出" class="headerlink" title="6.1 Datagrip 数据导出"></a>6.1 Datagrip 数据导出</h3><ul>
<li><p>右键导出csv或xlsx数据表用于熟悉数据字段，不懂或不清晰的一定要向同事或数仓请教</p>
</li>
<li><p>mysql导出csv乱码，是csv文件本身的文本编码问题导致的</p>
<ol>
<li>鼠标右键点击选中的 csv 文件，在弹出的菜单中选择“编辑”，则系统会用文本方式（记事本）打开该 csv 文件； </li>
</ol>
</li>
</ul>
<ol start="2">
<li>打开 csv 文件后，进行“另存为”操作，在弹出的界面底部位置有“编码”，修改编码方式即可： 从UTF-8改成 ANSI 。保存；</li>
<li>再用 excel 打开后，显示汉字正常。</li>
</ol>
<h3 id="6-2-excel导入本地mysql"><a href="#6-2-excel导入本地mysql" class="headerlink" title="6.2 excel导入本地mysql"></a>6.2 excel导入本地mysql</h3><h4 id="SQLyog"><a href="#SQLyog" class="headerlink" title="SQLyog"></a>SQLyog</h4><ol>
<li>创建数据库</li>
<li>导入外部数据库（开始新工作）</li>
<li>excel（csv注意格式）–&gt; 选择文件</li>
<li>从数据源拷贝</li>
<li>选择sheet</li>
</ol>
<h4 id="Datagrip"><a href="#Datagrip" class="headerlink" title="Datagrip"></a>Datagrip</h4><p><strong>本地数据时区问题说明</strong></p>
<p>Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingjiawen/p/14200327.html">https://www.cnblogs.com/qingjiawen/p/14200327.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找到mysql安装目录下的my.ini文件（找不到文件可能隐藏，或局搜索）</span><br><span class="line">默认安装目录</span><br><span class="line">C:\ProgramData\MySQL</span><br></pre></td></tr></table></figure>

<p>我的安装目录在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\ProgramData\MySQL\MySQL Server 8.0</span><br></pre></td></tr></table></figure>

<p>在my.ini文件最后一行输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-time_zone=&#x27;+8:00&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/262201/202101/262201-20210111212125309-900906212.png" alt="img"></p>
<h2 id="7-场景用法总结"><a href="#7-场景用法总结" class="headerlink" title="7 场景用法总结"></a>7 场景用法总结</h2><h3 id="7-1-自身使用习惯问题小结"><a href="#7-1-自身使用习惯问题小结" class="headerlink" title="7.1 自身使用习惯问题小结"></a>7.1 自身使用习惯问题小结</h3><ol>
<li><p>group by 后多使用having而不是套子查询用where，节省代码复杂度。</p>
</li>
<li><p>熟悉窗口函数使用，窗口函数可直接调用聚合函数。</p>
</li>
<li><p>count和sum的使用区别，同时注意聚合函数要考虑好 group by 的使用。</p>
</li>
<li><p>有些情况表连接效率高（可使用表自连接），有些情况多重子查询效率高。</p>
</li>
<li><p>使用 with as 用法优化代码。</p>
</li>
<li><p>练习计算同比环比</p>
</li>
</ol>
<h3 id="7-2-实用代码"><a href="#7-2-实用代码" class="headerlink" title="7.2 实用代码"></a>7.2 实用代码</h3><p>只举例部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> months <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">12</span>) <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) num <span class="comment">--逻辑函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,<span class="keyword">case</span> <span class="keyword">when</span> 枚举</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> datediff(<span class="built_in">cast</span>(midw.cre_dt <span class="keyword">as</span> <span class="type">date</span>),<span class="built_in">cast</span>(uif.cmdat_mmv_suc_ft <span class="keyword">as</span> <span class="type">date</span>)) <span class="operator">&lt;=</span><span class="number">61</span></span><br><span class="line">		  <span class="keyword">then</span> midw.amount</span><br><span class="line">		  <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)	amount_2ms_diff                <span class="comment">--聚合函数和case when联用</span></span><br><span class="line">,<span class="built_in">sum</span>(if(r <span class="operator">&lt;=</span> <span class="number">0.25</span>,成交额，<span class="number">0</span>))                           <span class="comment">--前四分之一用户成交金额</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">,<span class="built_in">cast</span>(sif.reg_time <span class="keyword">as</span> datetime)                        <span class="comment">--避免时间没有正确排序</span></span><br><span class="line"><span class="comment">-- 2019-08-03 10:13:02</span></span><br><span class="line"><span class="comment">-- 2019-08-03 7:50:01</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">distinct</span> user_id</span><br><span class="line">,<span class="number">1</span>													   <span class="comment">--生成标记（后续成交用户数）</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,<span class="built_in">sum</span>(<span class="built_in">sum</span>(amount))<span class="keyword">over</span>()                                <span class="comment">--总成交额</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">avg</span>(a.GMV)                                            <span class="comment">--求月平均</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">    门店名称</span><br><span class="line">    ,<span class="built_in">substring</span>(日期,<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">    ,<span class="built_in">sum</span>(GMV) GMV   <span class="comment">--注意别名</span></span><br><span class="line">    <span class="keyword">from</span> ddm.shop</span><br><span class="line">    <span class="keyword">where</span> <span class="built_in">substring</span>(日期,<span class="number">1</span>,<span class="number">4</span>) <span class="operator">=</span> <span class="string">&#x27;2020&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">sum</span>(GMV) <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">) a</span><br></pre></td></tr></table></figure>

<h2 id="8-刷题"><a href="#8-刷题" class="headerlink" title="8 刷题"></a>8 刷题</h2><ul>
<li><a target="_blank" rel="noopener" href="https://sqlzoo.net/wiki/SQL_Tutorial">sqlzoo刷题</a><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/gonerkong/sqlzoo_solutions">sqlzoo答案</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/sql">牛客网</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ifucode.com/2021/05/09/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckoiu9m1g00014wvia1l988tu" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/09/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T15:25:46.077Z" itemprop="datePublished">2021-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ifucode.com/2021/05/09/hello-world/" data-id="ckoiu9m0o00004wvi8ghodgjc" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/09/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 isleon<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>